Расчет адресов переменных и параметров функций.

Адреса переменных и параметров функций могут рассчитываться во время выполнения
программы или во время компиляции.

Если у функции установлен модификатор __stack, например:

int __stack calc(int a, int b) {
    return b + a;
}

То адреса вычисляются во время выполнения программы. Так работает стандартный
компилятор Си. В результате компиляции получается большая и медленная программа:

ld hl, 6
add hl, sp
ld c, (hl)
inc hl
ld b, (hl)
ld hl, 2
add hl, sp
ld e, (hl)
inc hl
ld d, (hl)
add hl, bc
ret

Если у функции установлен модификатор __global, например:

int __global calc(int a, int b) {
    return b + a;
}

То компилятор рассчитывает весь стек во время компиляции. Переменные и параметры
функции размещаются в оперативной памяти по фиксированному адресу. Рассчитанный
стек находится в переменной __static_stack. Адрес кадра стека конкретной
функции находится в переменной __s_(имя функции). Адрес параметра функции
находится в переменной __a_(номер параметра)_(имя функции строчными буквами).

По умолчанию выбран режим __global.

В результате компиляции мы получаем более короткую программу работающую в
несколько раз быстрее:

ex   hl, de
ld   hl, (__a_1_calc)
add  hl, de
ret

Но такие функции нельзя вызывать рекурсивно.
Если у функции фиксированное кол-во параметров и последний параметр это целое
число 8, 16 или 32 бит, то перед вызовом функции последний  параметр помещается
в регистры процессора: A, HL или DE + HL.

Вы можете использовать параметры функций в ассемблерных вставках.

uint8_t __global calc(uint8_t a, uint8_t b) {
    asm {
        ld   hl, __a_1
        add  (hl)
    }
}

Вы можете сами определить адрес параметра функции, например, сохранение 
параметра прямо в код команды:

uint8_t __global calc(uint8_t a, uint8_t b) {
    asm {
__a_1_calc=$+1
        add  0
    }
}

В результате компиляции получится еще более короткая программа:

ld (__a_2_calc), a
__a_1_calc=$+1
add  0
ret

Первую строку добавил компилятор. Если вы не хотите, чтобы компилятордобавлял 
эту строку, то добавьте конструкцию "__a_2_calc=0". Это значит, чтоу параметра
нет адреса.

uint8_t __global calc(uint8_t a, uint8_t b) {
    asm {
__a_2_calc=0
__a_1_calc=$+1
        add  0
    }
}

Получится самый короткий вариант функции:

__a_1_calc=$+1
add  0
ret
